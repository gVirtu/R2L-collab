
#define PL_TILE_SIZE 100
#define PL_FRAME_OFFSET_HORIZONTAL 5
#define PL_FRAME_OFFSET_VERTICAL 20

#define PL_RELOAD_FRAMES 19
#define PL_ANIM_RELOAD_START 1

#define PL_DEATH_FRAMES 10
#define PL_ANIM_DEATH_START 30


#define PL_ANIM_IDLE_START 0


/********************  RANDOM QUOTES ********************/
var& SDL_Open_Sound snd_RAND_1 = spawn SDL_Open_Sound("res/snds/rand_corpo.wav");
var& SDL_Open_Sound snd_RAND_2 = spawn SDL_Open_Sound("res/snds/rand_michael.wav");
var& SDL_Open_Sound snd_RAND_3 = spawn SDL_Open_Sound("res/snds/rand_pedacinho.wav");
var& SDL_Open_Sound snd_RAND_4 = spawn SDL_Open_Sound("res/snds/rand_tedio.wav");
var& SDL_Open_Sound snd_RAND_5 = spawn SDL_Open_Sound("res/snds/rand_viver.wav");
var& SDL_Open_Sound snd_RAND_6 = spawn SDL_Open_Sound("res/snds/rand_vivo.wav");


/********************  SHOT QUOTES ********************/
var& SDL_Open_Sound snd_SHOT_1 = spawn SDL_Open_Sound("res/snds/shot_morram.wav");
var& SDL_Open_Sound snd_SHOT_2 = spawn SDL_Open_Sound("res/snds/shot_risada_1.wav");
var& SDL_Open_Sound snd_SHOT_3 = spawn SDL_Open_Sound("res/snds/shot_risada_2.wav");


/********************  PAIN/DEATH ********************/
var& SDL_Open_Sound snd_PAIN_1 = spawn SDL_Open_Sound("res/snds/dor_1.wav");
var& SDL_Open_Sound snd_PAIN_2 = spawn SDL_Open_Sound("res/snds/dor_2.wav");
var& SDL_Open_Sound snd_PAIN_3 = spawn SDL_Open_Sound("res/snds/dor_3.wav");
var& SDL_Open_Sound snd_PAIN_4 = spawn SDL_Open_Sound("res/snds/dor_4.wav");
var& SDL_Open_Sound snd_DEATH  = spawn SDL_Open_Sound("res/snds/_morte.wav");

/********************  ZOMBIE DEATH QUOTES ********************/
var& SDL_Open_Sound snd_ZD_1 = spawn SDL_Open_Sound("res/snds/mz_batata.wav");
var& SDL_Open_Sound snd_ZD_2 = spawn SDL_Open_Sound("res/snds/mz_morreu.wav");
var& SDL_Open_Sound snd_ZD_3 = spawn SDL_Open_Sound("res/snds/mz_pontaria.wav");
var& SDL_Open_Sound snd_ZD_4 = spawn SDL_Open_Sound("res/snds/mz_queixo.wav");
var& SDL_Open_Sound snd_ZD_5 = spawn SDL_Open_Sound("res/snds/mz_rosto.wav");


/******************* SHOT SOUNDS ***********************/
var& SDL_Open_Sound snd_SHOT = spawn SDL_Open_Sound("res/shot_d.wav");

var& SDL_Open_Image tx_player_recharge = spawn SDL_Open_Image( &sdl!.ren, "res/spritesheet.png");
var& SDL_Open_Image tx_player_idle = spawn SDL_Open_Image( &sdl!.ren, "res/char_idle.png");


//

code/await Player(var float x0, var float y0)-> 
				(var float playerOrigin_x, 
				var float playerOrigin_y, 
				var int playerHealth,
				event void zombieDeath,
				event void zombieTouch,
				var SDL_Rect collider,
				event void die) -> FOREVER do
	
	
	/******** PLAYER **************/
	//{
	var float playerSize = 80.0;
	playerHealth = 100;
	
	event void random;
	event void shot;
	event void pain;
	event void death;
	event bool invFrames;

	var SDL_Rect fg = val SDL_Rect(x0 as int, y0 as int, playerSize as int, playerSize as int);
	collider = val SDL_Rect((x0 + 30) as int, (y0+30) as int, (playerSize-60) as int, (playerSize-60) as int);
	var SDL_Rect render = val SDL_Rect(x0 as int, y0 as int, playerSize as int, playerSize as int);
	//}
	
	/******** ANIMATION **********/ 
	//{
	var int animationFrame = 0;

	//}
	
	/******** SHOT **************/
	//{
	var int shotSpeed = 60;
	var int shotSize = 10;	
	var Vec2d shotSpawner = val Vec2d(0, 0);
	var int spawnerOffset = 2;
	//}
	
	/******** PLAYER MOVEMENT **************/
	//{
	var float angle = 0.0;
	var float radius = playerSize/2;

	var int target_x = 0;
	var int target_y = 0;

	var int xc = (x0 + 30) as int;
	var int yc = (y0 + 30) as int;
	
	var int x = x0 as int;
	var int y = y0 as int;
	var int vx = 0;
	var int vy = 0; 
	var int spd = 20;
	var bool mouse = true;
	var int dt = 0;

	var int gridx = (x+(radius as int))/BLOCK_SIZE;
    var int gridy = (y+(radius as int))/BLOCK_SIZE;
	
	playerOrigin_x = 0;
	playerOrigin_y = 0;
	var Vec2d playerDirection = _;
	
	code/tight UpdateOrigin(void) -> void do
		outer.playerOrigin_x = outer.fg.x + outer.radius;
		outer.playerOrigin_y = outer.fg.y + outer.radius;
	end
	//}
	
	/******** VOICE *************/
	//{
	var bool speaking = false;
	
 	code/await PlayVoice(var& SDL_Open_Sound snd) -> void do
	 	var int ret;
		ret = _Mix_PlayChannel(outer.voiceChannel, &&snd.sound, 0);
		_PRINTNOTHING("-------------------PLAY SOUND RESULT = %d\n",ret);
	end
	
	code/await PlayRandom(void) -> void do
		var int tmp = _rand()%4;
		if(tmp == 1) then
			//_PRINTNOTHING("BIRRRL\n");
			if (_Mix_Playing(outer.voiceChannel) == 0) then 
				var int voice = (_rand()%7);
				if(voice == 0) then
					spawn PlayVoice(&outer.snd_RAND_1);
				else/if(voice == 1) then
					spawn PlayVoice(&outer.snd_RAND_2);
				else/if(voice == 2) then
					spawn PlayVoice(&outer.snd_RAND_3);
				else/if(voice == 3) then 
					spawn PlayVoice(&outer.snd_RAND_4);
				else/if(voice == 4) then
					spawn PlayVoice(&outer.snd_RAND_5) ;
				else
					spawn PlayVoice(&outer.snd_RAND_6);
				end
			end
			await 10s;
		end
	end
	
	code/await PlayShot(void) -> void do
		var int tmp = _rand()%4;
		if(tmp == 1) then
			//_PRINTNOTHING("BIRRRL\n");
			if (_Mix_Playing(outer.voiceChannel) == 0) then 
				var int voice = (_rand()%3) - 1;
				if(voice == 0) then
					spawn PlayVoice(&outer.snd_SHOT_1);
				else/if(voice == 1) then
					spawn PlayVoice(&outer.snd_SHOT_2);
				else
					spawn PlayVoice(&outer.snd_SHOT_3);
				end
			end
			await 10s;
		end
	end
	
	code/await PlayPain(void) -> void do
		//_PRINTNOTHING("BIRRRL\n");
		if (_Mix_Playing(outer.voiceChannel) == 1) then
			_Mix_HaltChannel(outer.voiceChannel);
		end
		var int voice = (_rand()%4) - 1;
		if(voice == 0) then
			spawn PlayVoice(&outer.snd_PAIN_1);
		else/if(voice == 1) then
			spawn PlayVoice(&outer.snd_PAIN_2);
		else/if(voice == 2) then
			spawn PlayVoice(&outer.snd_PAIN_3);
		else
			spawn PlayVoice(&outer.snd_PAIN_4);
		end
		//await 4s;
	end
	
	
	code/await PlayKill(void) -> void do
		var int tmp = _rand()%2;
		if(tmp == 1) then
			//_PRINTNOTHING("BIRRRL\n");
			if (_Mix_Playing(outer.voiceChannel) == 0) then 
				var int voice = (_rand()%5) - 1;
				if(voice == 0) then
					spawn PlayVoice(&outer.snd_ZD_1);
				else/if(voice == 1) then
					spawn PlayVoice(&outer.snd_ZD_2);
				else/if(voice == 2) then
					spawn PlayVoice(&outer.snd_ZD_3);
				else/if(voice == 2) then
					spawn PlayVoice(&outer.snd_ZD_4);
				else
					spawn PlayVoice(&outer.snd_ZD_5);
				end
			end
			await 10s;
		end
	end
	//}

	
	// States of the keys:     W      A      S      D
	//                         |      |      |      |
  	vector[4] bool states = [false, false, false, false];
	
	
	par/or do
		every dt in SDL_DT do
			var bool updateChasers = false;
		
			var bool go_x = true;
			var bool go_y = true;

			{const u8 *st = SDL_GetKeyboardState(0);}

			{int mx=0, my=0; SDL_GetMouseState(&mx, &my);}

			target_x = {mx};
			target_y = {my};
			
			vx = (({st[SDL_SCANCODE_A]} as int)*(-spd)) + (({st[SDL_SCANCODE_D]} as int)*spd);
			vy = (({st[SDL_SCANCODE_W]} as int)*(-spd)) + (({st[SDL_SCANCODE_S]} as int)*spd);
			
			var int xf = x + vx*dt/100;
			var int yf = y + vy*dt/100;
			
			var int xcf = collider.x + vx*dt/100;
			var int ycf = collider.y + vy*dt/100;
 			
			if xcf < 0 or xcf > (outer.level_width - 2*radius) then
				go_x = false;
			end
			
			if ycf < 0 or ycf > (outer.level_height - 2*radius) then
				go_y = false;
			end
			
			var SDL_Rect tmp_x = val SDL_Rect(xcf, collider.y, collider.w, collider.h);
			var SDL_Rect tmp_y = val SDL_Rect(collider.x, ycf, collider.w, collider.h);
			
			var&? CollisionBlock block;
			
			loop block in outer.blocks do
				if (call Intersects(&block!.collision, &tmp_x)) then
					go_x = false;
				end
				if (call Intersects(&block!.collision, &tmp_y)) then
					go_y = false;
				end
				if ( go_x == false) and (go_y == false) then
					break;
				end
			end
			
			if go_x then
				x = xf;
				xc = xcf;

				if ((x+(radius as int))/BLOCK_SIZE != gridx) then
					gridx = (x+(radius as int))/BLOCK_SIZE;
					updateChasers = true;
				end
			end
			
			if go_y then
				y = yf; 
				yc = ycf;

				if ((y+(radius as int))/BLOCK_SIZE != gridy) then
					gridy = (y+(radius as int))/BLOCK_SIZE;
					updateChasers = true;
				end
			end
			
			if (updateChasers) then
                emit outer.retracePaths;
            end
			
			call UpdateOrigin();
			
			render.x = fg.x - outer.camera.x;
			render.y = fg.y - outer.camera.y;
			
			var Vec2d vec = call Vec_GetDirection(  ((playerOrigin_x) as int) - outer.camera.x, 
													((playerOrigin_y) as int) - outer.camera.y, 
													target_x, 
													target_y);
			var Vec2d yaxis = call Vec_GetDirection( 0, 0, 0, -1);
			angle = call Vec_AngleBetween(yaxis, vec);
			vec = call Vec_Normalize(vec);
			playerDirection = vec;

			collider.x = xc;
			collider.y = yc;
	
			fg.x = x;
			fg.y = y;
			
			shotSpawner.x = playerOrigin_x + (playerDirection.x * (radius + spawnerOffset));
			shotSpawner.y = playerOrigin_y + (playerDirection.y * (radius + spawnerOffset));

		end
	with // HEALTH
		
		loop do
			await zombieTouch;
			playerHealth = playerHealth - 20;
			_PRINTNOTHING("AAAAAAAAAAAAAAAAAAAAAI\n");
			_PRINTNOTHING("Health: %d\n", playerHealth);
			emit outer.healthHud!.health(playerHealth);
			emit pain;
			if playerHealth <= 0 then
				emit die;
			else 
				watching 1s do
					loop do
						emit invFrames(true);
						await 100ms;
						emit invFrames(false);
						await 100ms;
					end
				end
			end			
		end
	
	
	with // PLAY RANDOM VOICE
		
		//pool[1] PlayRandom v;
		//every 1s do 
		loop do
			par/or do
				par/or do
					await 10s;
					spawn PlayRandom();
					//await 10s;
				with
					await shot;
					_PRINTNOTHING("EVENT SHOT\n");
					spawn PlayShot();
					await 1s;
				with
					await zombieDeath;
					_PRINTNOTHING("LALALALALA\n");
					spawn PlayKill();
					//await 7s;
				end
				await 7s;
			with
				await pain;
				spawn PlayPain();
			end
		end
	
	
	 /************** KEYBOARD **********************/
	 //{
		 /*
	with // KEYBOARD W
		loop do
			var _SDL_KeyboardEvent&& kb;
			kb = await SDL_KEYDOWN until kb:keysym.sym == _SDLK_w;
			_PRINTNOTHING("W\n");
			states[0] = true;
			kb = await SDL_KEYUP until kb:keysym.sym == _SDLK_w;
			states[0] = false;
		end
	with // KEYBOARD A
		loop do
			var _SDL_KeyboardEvent&& kb;
			kb = await SDL_KEYDOWN until kb:keysym.sym == _SDLK_a;
			_PRINTNOTHING("A\n");
			states[1] = true;
			kb = await SDL_KEYUP until kb:keysym.sym == _SDLK_a;
			states[1] = false;
		end		
	with // KEYBOARD S
		loop do
			var _SDL_KeyboardEvent&& kb;
			kb = await SDL_KEYDOWN until kb:keysym.sym == _SDLK_s;
			_PRINTNOTHING("S\n");
			states[2] = true;
			kb = await SDL_KEYUP until kb:keysym.sym == _SDLK_s;
			states[2] = false;
		end
	with // KEYBOARD D
		loop do
			var _SDL_KeyboardEvent&& kb;
			kb = await SDL_KEYDOWN until kb:keysym.sym == _SDLK_d;
			_PRINTNOTHING("D\n");
			states[3] = true;
			kb = await SDL_KEYUP until kb:keysym.sym == _SDLK_d;
			states[3] = false;
		end
	 //}*/
	
	/************** MOUSE_CLICK ********************/
	//{
	with // MOUSE CLICK

		loop do
			var _SDL_MouseButtonEvent&& mb;
			mb = await SDL_MOUSEBUTTONDOWN until mb:button == _SDL_BUTTON_LEFT;
			var int dist = call Vec_GetDistance(mb:x + outer.camera.x, 
												mb:y + outer.camera.y, 
												(playerOrigin_x) as int, 
												(playerOrigin_y) as int) as int;
			if dist > 50 then 

				_Mix_PlayChannel(-1, &&outer.snd_SHOT.sound, 0);
				var Vec2d dir = call Vec_GetDirection(shotSpawner.x as int, 
							                          shotSpawner.y as int, 
													  mb:x + outer.camera.x, 
													  mb:y + outer.camera.y);

				var int i;
				loop i in [0 -> 6[ do
					var int rot_angle = (i-3)*4;

					var float cos = _cos(call DegreeToRad(rot_angle as float));
					var float sin = _sin(call DegreeToRad(rot_angle as float));

					var float xi = dir.x*cos - dir.y*sin;
					var float yi = dir.x*sin + dir.y*cos;

					var Vec2d tmp_vec = val Vec2d(xi, yi);
					
					spawn Shot( shotSpawner.x as int, 
								shotSpawner.y as int,
								tmp_vec,
								shotSpeed +((_rand()%2)*(-1)) * (_rand()%3) ,
								shotSize,
								0) in outer.shots;
				end
	
				animationFrame = PL_ANIM_RELOAD_START;
				_PRINTNOTHING("sound\n");
				emit shot;
				await 750ms;
			end
		end
	//}
	/*with // MOUSE MOVEMENT	
		var _SDL_MouseMotionEvent&& mse;
		every mse in SDL_MOUSEMOTION do
			target_x = mse:x;
			target_y = mse:y;
		end*/
	with 
        every 80ms do
			if(animationFrame >= PL_ANIM_RELOAD_START) then
				animationFrame = call NextFrame(animationFrame, PL_RELOAD_FRAMES + PL_ANIM_RELOAD_START - 1);
			end
        end

	with   // RENDER
		pause/if invFrames do
			every SDL_REDRAW do	
				var SDL_Rect clip_rect = call GetFrameRect(animationFrame, PL_TILE_SIZE,
														   PL_FRAME_OFFSET_HORIZONTAL,
														   PL_FRAME_OFFSET_VERTICAL,
														   -2*PL_FRAME_OFFSET_HORIZONTAL,
														   0);
				
				var SDL_Rect tmp = val SDL_Rect(fg.x - outer.camera.x,
												fg.y - outer.camera.y,
												playerSize as int, 
												playerSize as int);
				
				_SDL_RenderCopyEx(  &&outer.sdl!.ren, 
									&&outer.tx_player_recharge.tex.tex, 
									&&clip_rect as _SDL_Rect&&,
									&&tmp as _SDL_Rect&&, 
									angle, null, _SDL_FLIP_NONE);

			end
		end
	with
		await die;
	end
	
	if (_Mix_Playing(outer.voiceChannel) == 1) then
		_Mix_HaltChannel(outer.voiceChannel);
	end
	spawn PlayVoice(&outer.snd_DEATH);
	emit outer.playerDied;
	_PRINTNOTHING("MORREU\n");
	var SDL_Rect clip_rect = call GetFrameRect(	39, PL_TILE_SIZE,
												PL_FRAME_OFFSET_HORIZONTAL,
												PL_FRAME_OFFSET_VERTICAL,
												-2*PL_FRAME_OFFSET_HORIZONTAL,
												0);
	par do 
		every SDL_REDRAW do	
			
			
			var SDL_Rect tmp = val SDL_Rect(fg.x - outer.camera.x,
											fg.y - outer.camera.y,
											playerSize as int, 
											playerSize as int);
			
			_SDL_RenderCopyEx(  &&outer.sdl!.ren, 
								&&outer.tx_player_recharge.tex.tex, 
								&&clip_rect as _SDL_Rect&&,
								&&tmp as _SDL_Rect&&, 
								angle, null, _SDL_FLIP_NONE);

		end
	with

	end

end
